\chapter{KIẾN THỨC HỆ THỐNG}

\section{Cơ sở lý thuyết của kiến trúc}

\subsection{Kiến trúc Onion}

Onion Architecture (Kiến trúc củ hành) được xây dựng dựa trên ý tưởng đặt Domain vào trung tâm ứng dụng, mở rộng cơ chế phân phối (UI) và cơ sở hạ tầng được xây dựng bởi hệ thống.

Các tầng được biểu diễn thành dạng các vòng tròn đồng tâm. Đặc trưng của kiến trúc củ hành đó là một luật về sự ràng buộc giữa các tầng. Tầng bên ngoài chỉ phụ thuộc và gọi trực tiếp tầng bên trong. Các tầng thấp hơn không thể phụ thuộc vào các tầng bên ngoài.

Hầu hết các kiến trúc truyền thống đều nêu lên những vấn đề cơ bản về sự kết hợp giữa các thành phần một cách chặt chẽ và tách biệt. Kiến trúc Onion được Jeffrey Palermo giới thiệu để cung cấp một cách tốt hơn để xây dựng các ứng dụng theo quan điểm về khả năng kiểm tra, khả năng bảo trì và độ tin cậy tốt hơn.

\subsubsection{Nguyên lý}

Kiến trúc Onion dựa trên sự đảo ngược của nguyên tắc điều khiển. Kiến trúc Onion bao gồm nhiều lớp đồng tâm giao nhau về phía lõi đại diện cho miền. Kiến trúc không phụ thuộc vào lớp dữ liệu như trong các kiến trúc nhiều tầng cổ điển, mà dựa trên các mô hình miền thực tế.

Theo kiến trúc truyền thống, lớp giao diện người dùng tương tác với logic nghiệp vụ và logic nghiệp vụ nói chuyện với lớp dữ liệu và tất cả các lớp được trộn lẫn và phụ thuộc nhiều vào nhau. Trong kiến trúc 3 tầng và n tầng, không có lớp nào là độc lập. Những hệ thống như vậy rất khó hiểu và khó bảo trì. Hạn chế của kiến trúc truyền thống này là khớp nối không cần thiết.

Kiến trúc Onion đã giải quyết vấn đề này bằng cách xác định các lớp từ lõi đến Cơ sở hạ tầng. Nó áp dụng quy tắc cơ bản bằng cách di chuyển tất cả các khớp nối về phía trung tâm. Kiến trúc này chắc chắn thiên về lập trình hướng đối tượng và nó đặt các đối tượng trước tất cả các đối tượng khác. Trung tâm của Kiến trúc Onion là mô hình miền, đại diện cho các đối tượng hành vi và nghiệp vụ. Xung quanh lớp miền là các lớp khác, với nhiều hành vi hơn.

\subsubsection{Các lớp của Kiến trúc Onion}

\begin{figure}[ht]
	\centering
	\includegraphics[width = 1\textwidth]{onion_architecture}
	\caption{Các lớp của Kiến trúc Onion}
\end{figure}

\textbf{Domain Layer - Lớp tên miền}

Ở phần trung tâm của Kiến trúc Onion, lớp miền tồn tại; lớp này đại diện cho các đối tượng nghiệp vụ và hành vi. Ý tưởng là có tất cả các đối tượng miền của bạn ở cốt lõi này. Nó chứa tất cả các đối tượng miền ứng dụng. Bên cạnh các đối tượng miền, bạn cũng có thể có các giao diện miền. Các thực thể miền này không có bất kỳ phụ thuộc nào.

\textbf{Repository Layer - Lớp kho lưu trữ}

Lớp này tạo ra một sự trừu tượng giữa các thực thể miền và logic nghiệp vụ của một ứng dụng. Trong lớp này, thường thêm các giao diện cung cấp hành vi lưu và truy xuất đối tượng thường bằng cách liên quan đến cơ sở dữ liệu. Lớp này bao gồm mẫu truy cập dữ liệu, là một cách tiếp cận kết hợp lỏng hơn để truy cập dữ liệu. Chúng tôi cũng tạo một kho lưu trữ chung và thêm các truy vấn để truy xuất dữ liệu từ nguồn, ánh xạ dữ liệu từ nguồn dữ liệu sang một thực thể kinh doanh và duy trì những thay đổi trong thực thể kinh doanh đối với nguồn dữ liệu.

\textbf{Services Layer - Lớp dịch vụ}

Lớp Dịch vụ giữ các giao diện với các hoạt động phổ biến, chẳng hạn như Thêm, Lưu, Chỉnh sửa và Xóa. Ngoài ra, lớp này được sử dụng để giao tiếp giữa lớp UI và lớp kho lưu trữ. Lớp Dịch vụ cũng có thể giữ logic nghiệp vụ cho một thực thể. Trong lớp này, các giao diện dịch vụ được giữ với quá trình triển khai của nó, giữ cho sự liên kết lỏng và tách biệt các mối quan tâm trong tâm trí.

\textbf{UI Layer - Lớp giao diện người dùng}

Đây là lớp ngoài cùng và giữ các mối quan tâm ngoại vi như giao diện người dùng và các thử nghiệm. Đối với một ứng dụng Web, nó đại diện cho dự án Web API hoặc Unit Test. Lớp này có sự triển khai của nguyên tắc tiêm phụ thuộc để ứng dụng xây dựng một cấu trúc liên kết lỏng và có thể giao tiếp với lớp bên trong thông qua các giao diện.

\subsection{Kiến trúc mô-đun}

Kiến trúc mô-đun (Modular Architecture) là kiểu kiến trúc phần mềm cho phép quản lý sự phức tạp của một vấn đề bằng cách chia nhỏ chúng thành các mô-đun để dễ quản lý hơn với các nguyên tắc và mô hình. Mô-đun là một đơn vị phần mềm không trạng thái có thể triển khai, quản lý, tái sử dụng, kết hợp lại và cung cấp giao diện ngắn gọn cho người dùng.

Khi phát triển phần mềm, khi hệ thống càng lớn thì càng cần thêm nhiều component, dẫn tới sự thay đổi nhỏ trong một component có thể ảnh hưởng tới nhiều component khác. Trong hệ thống, module là những component được phát triển bên ngoài ứng dụng. Module giao tiếp với ứng dụng thông qua entry-point.

\begin{figure}[ht]
	\centering
	\includegraphics[width = 1\textwidth]{modules}
	\caption{Kiến trúc mô-đun}
\end{figure}

Sử dụng kiến trúc mô-đun đem lại một số lợi ích:

\begin{itemize}
	\bfitem{Tùy chỉnh}{ứng dụng có thể hoạt động thực sự khác biệt bằng cách chỉ bật / tắt một số mô-đun.}
	\bfitem{Ít phụ thuộc hơn}{các mô-đun độc lập hơn với chính ứng dụng, cho đến khi các "điểm vào" tương thích, cả mô-đun và ứng dụng có thể phát triển độc lập.}
	\bfitem{Các phần mở rộng của bên thứ ba}{vì các mô-đun không phải là một phần của ứng dụng và các "điểm vào" được xác định rõ, việc phát triển các mô-đun có thể được thực hiện bởi các bên thứ ba.}
	\bfitem{Phát triển độc lập}{Vì ứng dụng và các mô-đun là độc lập, chúng có thể là:}
	\begin{itemize}
		\item được phát triển bởi các nhà phát triển bên ngoài
		\item phát hành với các chu kỳ phát hành độc lập
		\item được phát triển tiềm năng với các công nghệ khác nhau
	\end{itemize}
	\bfitem{Ứng dụng nhỏ hơn}{Các ứng dụng nhỏ hơn (nhiều chức năng có thể được thực hiện thông qua các mô-đun) và ứng dụng nhỏ hơn được dịch để có khả năng bảo trì tốt hơn.}
\end{itemize}

Mô-đun được hình thành dựa trên việc nhóm những lớp có mức độ liên quan cao thành một mô-đun để có tính tương liên cao nhất. Có 2 loại tương liên:

\begin{itemize}
	\item Tương liên giao tiếp: có được khi 2 phần của mô-đun thao tác trên cùng dữ liệu.
	\item Tương liên chức năng: có được khi mọi phần của mô-đun làm việc cùng nhau để thực hiện tác vụ định rõ.
\end{itemize}

\section{Kiến trúc tổng quan hệ thống}

\subsection{Hệ thống frontend}

\subsubsection{Hệ thống Trang}

Hệ thống frontend có các hệ thống Trang sau đây: Product, Layer, Experiment và Test Group. Mỗi hệ thống Trang bao gồm có hệ thống Đường dẫn, mỗi Đường dẫn có một nhiệm vụ cụ thể được ghi chú trong Chú thích.

Mỗi thực thể đều có một hệ thống Trang nhằm mục đích cho người dùng có thể khởi tạo, cập nhập và thay đổi theo ý muốn. Ngoài ra người dùng có thể có cái nhìn toàn cảnh với mỗi thực thể.

\begin{table}[h!]
	\centering
	\begin{tabular}{|c|l|p{5cm}|}
		\hline
		Trang                       & Đường dẫn                                       & Chú thích                                      \\ \hline
		\multirow{4}{*}{Product}    & /product                                        & Hiển thị toàn bộ Product                       \\ \cline{2-3}
		                            & /product/new                                    & Khởi tạo một Product mới                       \\ \cline{2-3}
		                            & /product/:id                                    & Hiển thị một Product                           \\ \cline{2-3}
		                            & /product/:id/update                             & Cập nhật một Product                           \\ \hline
		\multirow{4}{*}{Layer}      & /product/:id/layer                              & Hiển thị toàn bộ Layer của một Product         \\ \cline{2-3}
		                            & /product/:id/layer/new                          & Khởi tạo một Layer mới                         \\ \cline{2-3}
		                            & /product/:id/layer/:id                          & Hiển thị một Layer                             \\ \cline{2-3}
		                            & /product/:id/layer/:id/update                   & Cập nhật một Layer                             \\ \hline
		\multirow{4}{*}{Experiment} & /product/:id/layer/:id/exp                      & Hiển thị toàn bộ Experiment của một Layer      \\ \cline{2-3}
		                            & /product/:id/layer/:id/exp/new                  & Khởi tạo một Experiment mới                    \\ \cline{2-3}
		                            & /product/:id/layer/:id/exp/:id                  & Hiển thị một Layer                             \\ \cline{2-3}
		                            & /product/:id/layer/:id/exp/:id/update           & Cập nhật một Layer                             \\ \hline
		\multirow{4}{*}{Group}      & /product/:id/layer/:id/exp/:id/group            & Hiển thị toàn bộ Test Group của một Experiment \\ \cline{2-3}
		                            & /product/:id/layer/:id/exp/:id/group/new        & Khởi tạo một Test Group mới                    \\ \cline{2-3}
		                            & /product/:id/layer/:id/exp/:id/group/:id        & Hiển thị một Test Group                        \\ \cline{2-3}
		                            & /product/:id/layer/:id/exp/:id/group/:id/update & Cập nhật một Test Group                        \\ \hline
	\end{tabular}
	\caption{Hệ thống Trang}
\end{table}

\subsubsection{Các thành phần}

Hệ thống frontend gồm các thành phần sau: Types, Pages, Features.

\begin{itemize}
	\bfitem{Types}{Mục đích là tổng hợp các thực thể ở tầng Frontend, bao gồm hai loại là Thực thể gốc và nội dung khi nhận/gửi API}
	\bfitem{Pages}{Là thành phần xử lý hệ thống Trang, mỗi file sẽ là một hệ thống Trang khác nhau}
	\bfitem{Features}{Là thành phần xử lý hệ thống thông tin cho toàn bộ hệ thống Frontend, bao gồm cả việc nhận, gửi dữ liệu từ Server}
\end{itemize}

\subsection{Hệ thống backend}

\subsubsection{Các thành phần}

Hệ thống backend gồm các thành phần sau: Service, Storage, Database, Types

\begin{itemize}
	\bfitem{Service}{Là thành phần xử lý hệ thống HTTP, chuyên nhận và phản hồi các truy cập từ hệ thống Frontend}
	\bfitem{Storage}{Là thành phần xử lý hệ thống tổng hợp thông tin cho hệ thống Backend}
	\bfitem{Database}{Là thành phần xử lý hệ thống quản lý dữ liệu cho hệ thống Backend}
	\bfitem{Types}{Tổng hợp các thực thể ở tầng Backend, bao gồm 2 loại là: Thực thể gốc và nội dung khi nhận/gửi API}
\end{itemize}

\begin{figure}[ht]
	\centering
	\includegraphics[width = 1\textwidth]{backend}
	\caption{Hệ thống Backend}
\end{figure}

\subsubsection{Hệ thống đường dẫn}

Hệ thống đường dẫn bao gồm các thực thể sau: Summary, AbTest, Product, Layer, Experiment và Test Group.

Mỗi thực thể có chức năng riêng biệt nhau.

\begin{table}[h!]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Thực thể}           & \textbf{Đường dẫn} & \textbf{Chú thích}                          \\ \hline
		Summary                     & /summary           & Gọi toàn bộ thông tin của hệ thống A/B Test \\ \hline
		AbTest                      & /abtest            & Thực hiện A/B Test                          \\ \hline
		\multirow{2}{*}{Product}    & /product/create    & Khởi tạo Product mới                        \\ \cline{2-3}
		                            & /product/update    & Cập nhật Product                            \\ \hline
		\multirow{2}{*}{Layer}      & /layer/create      & Khởi tạo Layer mới                          \\ \cline{2-3}
		                            & /layer/update      & Cập nhật Layer                              \\ \hline
		\multirow{2}{*}{Experiment} & /exp/create        & Khởi tạo Experiment mới                     \\ \cline{2-3}
		                            & /exp/update        & Cập nhật Experiment                         \\ \hline
		\multirow{2}{*}{Test Group} & /group/create      & Khởi tạo Test Group mới                     \\ \cline{2-3}
		                            & /group/update      & Cập nhật Test Group mới                     \\ \hline
	\end{tabular}
	\caption{Hệ thống đường dẫn}
\end{table}

\subsection{Biểu đồ tuần tự}

\subsubsection{Biểu đồ tuần tự chung}

Biểu đồ tuần tự chung biểu thị việc khởi tạo và sử dụng A/B Test.

\begin{figure}[H]
	\centering
	\includegraphics[width = 1\textwidth]{overview-sequence}
	\caption{Biểu đồ tuần tự chung}
\end{figure}

\subsubsection{Biểu đồ tuần tự khởi tạo A/B Test}

Biểu đồ tuần tự khởi tạo A/B Test biểu thị

\begin{figure}[H]
	\centering
	\includegraphics[width = 1\textwidth]{abtest-sequence}
	\caption{Biểu đồ tuần tự khởi tạo A/B Test}
\end{figure}

\section{Mô hình cơ sở dữ liệu}

Mô hình cơ sở dữ liệu của hệ thống mô tả cụ thể các đặc tính của mỗi thực thể, ngoài ra mô tả
cách lưu trữ các thực thể và các mối quan hệ tương quan trong cơ sở dữ liệu.

\subsection{Các thực thể}

Các thực thể bao gồm: Product, Layer, Experiment và Test Group.

\subsubsection{Product}

Product là thực thể lớn nhất, chỉ có chức năng phân tách theo nhu cầu sử dụng nên chỉ có 2 trường như sau:
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		Trường & Loại   & Chú thích       \\ \hline
		id     & int    & Unique id       \\ \hline
		name   & string & Tên của Product \\ \hline
	\end{tabular}
	\caption{Mô hình của Product}
\end{table}

Cấu hình khi được lưu xuống cơ sở dữ liệu:

\begin{itemize}
	\bfitem{Key}{product::[id]}
	\bfitem{Value}{binary (nén bởi protobuf)}
	\bfitem{Command}{SET, GET}
\end{itemize}

\subsubsection{Layer}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		Trường & Loại   & Chú thích      \\ \hline
		id     & int    & Unique id      \\ \hline
		name   & string & Tên của Layer  \\ \hline
		type   & int    & Loại của Layer \\ \hline
	\end{tabular}
	\caption{Mô hình của Layer}
\end{table}

Cấu hình khi được lưu xuống cơ sở dữ liệu:

\begin{itemize}
	\bfitem{Key}{layer::[id]}
	\bfitem{Value}{binary (nén bởi protobuf)}
	\bfitem{Command}{SET, GET}
\end{itemize}

\subsubsection{Experiment}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		Trường      & Loại   & Chú thích          \\ \hline
		id          & int    & Unique id          \\ \hline
		name        & string & Tên của Experiment \\ \hline
		traffic     & int    & Số lượng traffic   \\ \hline
		start\_time & int    & Thời điểm bắt đầu  \\ \hline
		end\_time   & int    & Thời điểm kết thúc \\ \hline
		status      & int    & Trạng thái         \\ \hline
	\end{tabular}
	\caption{Mô hình của Experiment}
\end{table}

Cấu hình khi được lưu xuống cơ sở dữ liệu:

\begin{itemize}
	\bfitem{Key}{exp::[id]}
	\bfitem{Value}{binary (nén bởi protobuf)}
	\bfitem{Command}{SET, GET}
\end{itemize}

\subsubsection{Test Group}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		Trường    & Loại   & Chú thích                \\ \hline
		id        & int    & Unique id                \\ \hline
		parameter & string & Parameter của Test Group \\ \hline
		value     & string & Value của Parameter      \\ \hline
	\end{tabular}
	\caption{Mô hình của Test Group}
\end{table}

Cấu hình khi được lưu xuống cơ sở dữ liệu:

\begin{itemize}
	\bfitem{Key}{group::[id]}
	\bfitem{Value}{binary (nén bởi protobuf)}
	\bfitem{Command}{SET, GET}
\end{itemize}

\subsection{Mối quan hệ giữa các thực thể}

Giữa các thực thể có các mối quan hệ lẫn nhau, vì vậy ngoài việc lưu trữ các thực thể dưới
cơ sở dữ liệu, cũng cần lưu trữ mối quan hệ giữa chúng.

\subsubsection{Tổng hợp các Product}

Khi cần query tất cả các Product hiện có, chỉ cần lưu các id của product vào một chỗ.

Cấu hình khi được lưu xuống cơ sở dữ liệu:

\begin{itemize}
	\bfitem{Key}{product::ids}
	\bfitem{Value}{các id của product}
	\bfitem{Command}{SADD, SMEMBERS}
\end{itemize}

\subsubsection{Giữa Product và Layer}

Mỗi Product có nhiều Layer, khi cần query tất cả các Layer dưới một Product, chỉ cần lưu
các id của layer vào một chỗ.

Cấu hình khi được lưu xuống cơ sở dữ liệu:

\begin{itemize}
	\bfitem{Key}{product::[id]::layers}
	\bfitem{Value}{các id của Layer}
	\bfitem{Command}{SADD, SMEMBERS}
\end{itemize}

\subsubsection{Giữa Layer và Experiment}

Mỗi Layer có nhiều Experiment, khi cần query tất cả các Experiment dưới một Layer, chỉ cần lưu
các id của Experiment vào một chỗ.

Cấu hình khi được lưu xuống cơ sở dữ liệu:

\begin{itemize}
	\bfitem{Key}{layer::[id]::exps}
	\bfitem{Value}{các id của Experiment}
	\bfitem{Command}{SADD, SMEMBERS}
\end{itemize}

\subsubsection{Giữa Experiment và Test Group}

Mỗi Experiment có nhiều Test Group, khi cần query tất cả các Test Group dưới một Experiment, chỉ cần lưu
các id của Test Group vào một chỗ.

Cấu hình khi được lưu xuống cơ sở dữ liệu:

\begin{itemize}
	\bfitem{Key}{exp::[id]::groups}
	\bfitem{Value}{các id của Test Group}
	\bfitem{Command}{SADD, SMEMBERS}
\end{itemize}

\subsection{Id generator}

Mỗi thực thể đều yêu cầu một mã ID định danh, do đó cơ sở dữ liệu cũng cần được sử dụng để mỗi
khi tạo một thực thể mới có thể có một mã ID định danh mới.

Cấu hình khi được lưu xuống cơ sở dữ liệu:

\begin{itemize}
	\bfitem{Key}{product::id, layer::id, exp::id, group::id}
	\bfitem{Value}{Mã ID đang sử dụng hiện tại}
	\bfitem{Command}{INCR}
\end{itemize}
